{"version":3,"sources":["Suit.ts","Card.tsx","Hand.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Suit","suitColor","suit","DIAMOND","HEART","Card","props","CLUB","SPADE","parseSuit","className","rank","Hand","renderedCards","cards","map","card","App","useState","hand","setHand","type","defaultValue","onChange","event","handRegex","RegExp","input","target","value","test","split","cardstr","filter","console","log","JSON","stringify","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"oNAAYA,E,8CAOL,SAASC,EAAUC,GACtB,OAAGA,IAASF,EAAKG,SAAWD,IAASF,EAAKI,MAC/B,MAEA,S,SAXHJ,K,oBAAAA,E,iBAAAA,E,qBAAAA,E,sBAAAA,M,WCcL,SAASK,EAAKC,GACjB,IAAMJ,EDAH,SAAmBA,GACtB,MAAY,MAATA,EACQF,EAAKO,KACG,MAATL,EACCF,EAAKI,MACG,MAATF,EACCF,EAAKG,QAELH,EAAKQ,MCRGC,CAAUH,EAAMJ,MACnC,OACI,uBAAKQ,UAAS,eAAUT,EAAUC,KAC9B,wBAAMQ,UAAU,gBAAgBJ,EAAMK,KAAMT,ICGjD,SAASU,EAAKN,GACjB,IAAMO,EAAgBP,EAAMQ,MAAMC,KAAI,SAACC,GACnC,OAAO,gBAAC,EAAD,CAAML,KAAMK,EAAKL,KAAMT,KAAMc,EAAKd,UAE7C,OACI,uBAAKQ,UAAU,QACVG,G,MCOEI,MA9Bf,WAAgB,IAAD,EACWC,mBAAS,CAC/B,CAACP,KAAM,IAAKT,KAAM,KAClB,CAACS,KAAM,IAAKT,KAAM,OAHP,mBACNiB,EADM,KACAC,EADA,KAkBb,OACE,yBAAKV,UAAU,OACb,4BAAQA,UAAU,cAChB,8BACE,2BAAOW,KAAK,OAAOC,aAAa,QAAQC,SAjB3B,SAACC,GACpB,IAAMC,EAAY,IAAIC,OAAO,0BACvBC,EAAQH,EAAMI,OAAOC,MAC3B,GAAGJ,EAAUK,KAAKH,GAAQ,CACxB,IAAMb,EAAQa,EAAMI,MAAM,KAAKhB,KAAI,SAACiB,GAClC,MAAO,CAACrB,KAAMqB,EAAQ,GAAI9B,KAAM8B,EAAQ,OACvCC,QAAO,SAACjB,GACT,OAAQA,EAAKL,MAAQK,EAAKd,QAE5BgC,QAAQC,IAAIC,KAAKC,UAAUvB,IAC3BM,EAAQN,SAUN,kBAACF,EAAD,CAAME,MAAOK,MCjBDmB,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDiIpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLrB,QAAQqB,MAAMA,EAAMC,c","file":"static/js/main.2e25a47d.chunk.js","sourcesContent":["export enum Suit {\n    CLUB = \"&clubs;️\",\n    DIAMOND = \"♦\",\n    HEART = \"&hearts;️\",\n    SPADE = \"&spades;️\"\n}\n\nexport function suitColor(suit: Suit): string {\n    if(suit === Suit.DIAMOND || suit === Suit.HEART) {\n        return \"red\";\n    } else {\n        return \"black\";\n    }\n}\n\nexport function parseSuit(suit: string): Suit {\n    if(suit === \"C\") {\n        return Suit.CLUB;\n    } else if(suit === \"H\") {\n        return Suit.HEART;\n    } else if(suit === \"D\") {\n        return Suit.DIAMOND;\n    } else {\n        return Suit.SPADE;\n    }\n}","import * as React from 'react';\nimport { Suit, parseSuit, suitColor } from './Suit';\nimport './Card.css';\n\nfunction rankFormat(rank: number): string {\n    if(rank === 1) { return \"A\" }\n    else if(rank === 11) { return \"J\"; }\n    else if(rank === 12) { return \"Q\"; }\n    else if(rank === 13) { return \"K\"; }\n    else {\n        return rank.toString(); \n    }\n}\n\nexport function Card(props: { rank: string, suit: string }): React.ReactElement {\n    const suit: Suit = parseSuit(props.suit);\n    return (\n        <div className={`card ${suitColor(suit)}`}>\n            <span className=\"cardIdentity\">{props.rank}{suit}</span>\n        </div>\n    );\n}","import * as React from 'react';\nimport { Card } from './Card';\n\nexport interface HandPropType {\n    cards: {rank: string, suit: string }[]\n}\n\nfunction rankToNumber(rank: string): number {\n    if(rank === \"A\") {\n        return 1;\n    } else if(rank === \"J\") {\n        return 11;\n    } else if(rank === \"Q\") {\n        return 12;\n    } else if(rank === \"K\") {\n        return 13;\n    } else {\n        return parseInt(rank);\n    }\n}\n\nexport function Hand(props: HandPropType): React.ReactElement {\n    const renderedCards = props.cards.map((card) => {\n        return <Card rank={card.rank} suit={card.suit} />\n    });\n    return (\n        <div className=\"hand\">\n            {renderedCards}\n        </div>\n    );\n}","import React, { useState } from 'react';\nimport { Hand } from './Hand';\nimport './App.css';\n\nfunction App() {\n  const [hand, setHand] = useState([\n    {rank: 'J', suit: 'S'},\n    {rank: '4', suit: 'H'},\n  ]);\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const handRegex = new RegExp(\"^([A2-9JKQ][CDHS] *)+$\");\n    const input = event.target.value; \n    if(handRegex.test(input)) {\n      const cards = input.split(\" \").map((cardstr: string) => {\n        return {rank: cardstr[0], suit: cardstr[1]}\n      }).filter((card: {rank: string, suit: string}) => {\n        return (card.rank && card.suit);\n      })\n      console.log(JSON.stringify(cards));\n      setHand(cards);\n    }\n  }\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <form>\n          <input type=\"text\" defaultValue='JS 4H' onChange={handleChange}></input>\n        </form>\n      </header>\n        <Hand cards={hand} />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}